<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="quarto-0.2.281">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>compmemlearn – introduction</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
  <script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
  <script src="../../../site_libs/clipboard/clipboard.min.js"></script>
  <meta name="quarto:offset" content="../../../">
  <script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
  <script src="../../../site_libs/quarto-search/fuse.min.js"></script>
  <script src="../../../site_libs/quarto-search/quarto-search.js"></script>
  <script src="../../../site_libs/quarto-html/quarto.js"></script>
  <script src="../../../site_libs/quarto-html/popper.min.js"></script>
  <script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
  <script src="../../../site_libs/quarto-html/anchor.min.js"></script>
  <link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
  <link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet">
  <script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
  <link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
  <link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet">
  <script id="quarto-search-options" type="application/json">{
    "location": "navbar",
    "copy-button": false,
    "collapse-after": 2,
    "panel-placement": "end",
    "type": "overlay",
    "limit": 20,
    "language": {
      "search-no-results-text": "No results",
      "search-matching-documents-text": "matching documents",
      "search-copy-link-title": "Copy link to search",
      "search-hide-matches-text": "Hide additional matches",
      "search-more-match-text": "more match in this document",
      "search-more-matches-text": "more matches in this document",
      "search-clear-button-title": "Clear",
      "search-detached-cancel-button-title": "Cancel",
      "search-submit-button-title": "Submit"
    }
  }</script>
  <link rel="stylesheet" href="../../../styles.css">
</head>
<body>
<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-light ">
      <div class="navbar-container container-fluid">
      <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">compmemlearn</span>
  </a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html">About</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- toc -->
    <nav id="TOC" role="doc-toc" class="sidebar sidebar-toc">
<h2 id="toc-title">On this page</h2>
<ul>
<li><a href="#instance-and-prototype-accounts-of-abstraction" class="nav-link active" data-scroll-target="#instance-and-prototype-accounts-of-abstraction">Instance and Prototype Accounts of Abstraction</a>
<ul class="collapse">
<li><a href="#models-of-free-recall-are-traditionally-prototype-based" class="nav-link" data-scroll-target="#models-of-free-recall-are-traditionally-prototype-based">Models of Free Recall are Traditionally Prototype-Based</a></li>
<li><a href="#research-approach" class="nav-link" data-scroll-target="#research-approach">Research Approach</a></li>
</ul></li>
</ul>
</nav>
<!-- main -->
<main class="content">

<section id="instance-and-prototype-accounts-of-abstraction" class="level2">
<h2 class="anchored" data-anchor-id="instance-and-prototype-accounts-of-abstraction">Instance and Prototype Accounts of Abstraction</h2>
<p>A central task of memory is to relate features of current experience with relevant and useful information from past experience; however, stored information relevant to a probe is often distributed across multiple learning episodes. To account for our ability to retrieve this information, models of memory search often specify some mechanism for abstraction – selective generalization across recurrent features of past experience <span class="citation" data-cites="yee2019abstraction">[@yee2019abstraction]</span>. Abstraction involves identifying and highlighting features common across experiential episodes while disregarding or suppressing reinstatement more idiosyncratic properties. Since this capacity is central to how memory systems retrieve relevant information from stored experience, much work has explored how humans carry it out.</p>
<p>Depending on how they characterize the process of abstraction, memory models can often be categorized as prototype- or instance-based. Prototype-based models conceptualize abstraction as a process enacted during encoding; new experiences are conceived as updating memory representations to reflect prototypical features that are common across past experiences. Connectionist models such as the multilayer perceptron are typically examples of prototype-based models <span class="citation" data-cites="jamieson2018instance">[@jamieson2018instance]</span>. Instead of being stored as separate records in memory, learning examples presented to a connectionist model each update a prototypical pattern of weights that eventually map memory probes to responses.</p>
<p>Instance-based models do store learning exampls as separate records in memory. The model architecture was originally identified to help understand how category learning might be possible without explicit storage of so-called abstract ideas <span class="citation" data-cites="hintzman1984minerva hintzman1986schema hintzman1988judgments">[@hintzman1984minerva; @hintzman1986schema; @hintzman1988judgments]</span>. Instance-based models posit that memory encoding primarily involves accumulating a record of every experience as separate traces in memory. Abstraction over stored instances later occurs at retrieval rather than during encoding, and unfolds through comparison of a memory cue with each instance stored in memory. The abstractive representation finally retrieved is a blend of the content in each stored instance, weighted such that information in the instances most similar to the probe is substantially more prominent than information in instances that are dissimilar to the probe. Because instance-based models preserve a discrete record of all relevant events in memory, they can often selectively retrieve information about even rare past events with high flexibility. <!--
Instance-based architecture might predate minerva 2??
--></p>
<p>Instance-based accounts of memory have faced scrutiny for implying that the number of stored instances in memory can increase without limit and are all contacted upon retrieval, respectively placing extraordinary capacity and processing demands on the human nervous system <span class="citation" data-cites="kahana2020computational">[e.g., @kahana2020computational]</span>. However, at the same time as instance-based models have been critiqued for their architectural lack of data compression at storage, the way abstractive representations exclude idiosyncratic features of individual learning episodes to reflect a center of tendency across them is similarly recurrently cited as a limitation of prototype-based models. In research on categorization for example, ‘exemplar-similarity’ models <span class="citation" data-cites="nosofsky2002exemplar stanton2002comparisons">[@nosofsky2002exemplar; @stanton2002comparisons]</span> outperform comparable prototype-based models by representing categories as sets of stored instances paired with a process for comparison against probes. A related analysis extends these findings to also critique prototype-based accounts of semantic memory. <span class="citation" data-cites="jamieson2018instance">@jamieson2018instance</span> found that because prototype-based distributional semantic models such as latent semantic analysis <span class="citation" data-cites="dumais2004latent">[@dumais2004latent]</span> and Word2Vec <span class="citation" data-cites="church2017word2vec">[@church2017word2vec]</span> “collapse the many contexts in which a word occurs to a single best-fitting representation”, they lose the ability to represent rare senses of homonymous and polymsemous words. Consequently, prototype-based models exhibited measureably worse performance accounting for word similarity patterns in various natural language simulations compared to an instance-based account of semantic memory based on the MINERVA 2 multiple traces memory model <span class="citation" data-cites="hintzman1984minerva">[@hintzman1984minerva]</span>. In the context of successes like these across diverse research conditions, instance-based accounts of memory have become increasingly prominent.</p>
<section id="models-of-free-recall-are-traditionally-prototype-based" class="level3">
<h3 class="anchored" data-anchor-id="models-of-free-recall-are-traditionally-prototype-based">Models of Free Recall are Traditionally Prototype-Based</h3>
<p>While instance-based models have organized formal work in a variety of research subfields, models of memory search primarily focused on accounting for performance on the free recall task largely countervail this pattern. In the free recall task paradigm, research participants are presented a sequence of items — usually a word list — to memorize during a study phase. Later, after a delay or perhaps some distraction task, participants are prompted to recall as many items from the list as possible, in whatever order they come to mind. Since participants largely organize the course of retrieval themselves in the response phase of a free recall task, work by researchers to characterize the organization of responses measured under the paradigm <span class="citation" data-cites="postman1971organization puff1979memory">[@postman1971organization; @puff1979memory]</span> have provided important constraints on accounts of the representations and mechanisms underlying search through memory to retrieve information.</p>
<p>In particular, three consistent regularities across experiments have received especial emphasis in accounts of performance on the free recall task <span class="citation" data-cites="kahana2020computational">[@kahana2020computational]</span>. The serial position effect identifies a nonlinear, U-shaped relationship between the position of an item within a study list — its serial position — and its probability of retrieval after encoding <span class="citation" data-cites="murdock1962serial">[@murdock1962serial]</span>. Researchers typically distinguish between the enhanced retrieval probabilities for early and terminal items; the advantage for the initially presented items is called the primacy effect, while the normally larger advantage for the few presented items is called the recency effect.</p>
<p>A similar but distinct pattern constraining accounts of memory search is found in analyses relating an item’s serial position with the probability that it will be recalled first in the retrieval phase of experiments. Pivotally, in list-based free recall tasks, participants tend to initiate recall with the most recently studied items from the list; however, in a <em>serial</em> recall task where participants are instructed to recall items in the order in which they were presented rather than freely, participants tend to successfully recall the earliest presented items first <span class="citation" data-cites="golomb2008effects">[for example in @golomb2008effects]</span>. This difference implies that while participants maintain and can access memories of item positions to perform a serial recall task, memory search and retrieval is organized by other features of experience.</p>
<p>Primacy and recency effects demonstrate that the temporal structure of the list affects the memorability of the items within it. This temporal structure can also be seen in the organization of responses throughout the response sequence, not just for initial and terminal items or recall positions. Free recall task data exhibits a pattern called <em>temporal contiguity</em> where items studied at nearby serial positions tend to be recalled near one another at the retrieval phase of an experiment. To quantify this pattern, researchers measure across trials the conditional probability of retrieving items given increasing inter-item lags between the serial positions of considered items and the serial position of the item last recalled. These lag-based condition response probability (lag-CRP) analyses find that subjects reliably tend to make transitions between temporally contiguous items (that is, items presented near one another) during free recall. Furthermore, they exhibit a forward bias, recalling contiguous items presented after the last recalled item more frequently than items presented before <span class="citation" data-cites="kahana1996associative">[@kahana1996associative]</span>.</p>
<p>To account for these phenomena, the formal literature has largely converged on retrieved context theories of memory search <span class="citation" data-cites="howard2002distributed polyn2009context morton2016predictive">[for example, @howard2002distributed; @polyn2009context; @morton2016predictive]</span>. Generally, according to these theories, as items are encoded into a memory system, an internal representational of temporal context is also maintained that dynamically updates itself to reflect a weighted summary of recent experience. As each item is studied, a Hebbian learning mechanism associates the item’s features to the current state of the context representation. Once associated, item features can cue retrieval of associated contextual features, and vice versa. When the retrieval phase comes, the current contextual representation can drive memory search by activating a blend of associated item features. This prompts a retrieval competition in which a particular item is selected and retrieved. Correspondingly, retrieving an item reactivates its associated contextual features, updating context before the next recall attempt. The retrieved context supports the neighbors of the just-recalled item, which gives rise to temporal organization.</p>
<p>With these basic mechanisms, retrieved-context models have been used to explain many phenomena, including serial and temporal organizational effects in list-learning tasks <span class="citation" data-cites="polyn2009context siegel2014retrieved schwartz2005shadows">[@polyn2009context; @siegel2014retrieved; @schwartz2005shadows]</span>, and broader domains such as financial decision making <span class="citation" data-cites="wachter2019retrieved">[@wachter2019retrieved]</span>, emotion regulation <span class="citation" data-cites="talmi2019retrieved">[@talmi2019retrieved]</span>, and neural signal dynamics within the medial temporal lobe <span class="citation" data-cites="kragel2015neural">[@kragel2015neural]</span>. Further model development has integrated retrieved context accounts of memory search with theories of semantic knowledge <span class="citation" data-cites="morton2016predictive">[@morton2016predictive]</span> and changes related to healthy aging <span class="citation" data-cites="healey2016four">[@healey2016four]</span>.</p>
<p>The framework used to implement most retrieved context models of memory search acts like a prototype model. These models typically encode memories associating contextual states and item features by updating connection weights within a simplified neural network. Through Hebbian learning, where co-activation of item and contextual features increase weights associating those features, the network accumulates a collapsed average representation reflecting the history of context and item interactions across experience. During retrieval, the network can be probed with a contextual cue to retrieve an item feature representation (or vice versa) based on a linear function of the cue’s content and stored context-to-item weights.</p>
<p>In contrast, an instance-based alternative would track this history by storing a discrete record of each experience with its unique temporal context in memory to perform abstraction over only at the point of retrieval. Previous instance-based accounts of performance on various tasks have emphasized a role of some sort of temporal contextual representation in organizing performance. Indeed, the original presentation of MINERVA 2, the first major instance-based memory modeling architecture, included a representation of list context as a feature in stored memory instances to model source-specific frequency judgments from memory <span class="citation" data-cites="hintzman1984minerva">[@hintzman1984minerva]</span>. <span class="citation" data-cites="lehman2013buffer">[@lehman2013buffer]</span> proposed an instance-based buffer model that accounts for patterns like recency and the position position effect in terms of storage and retrieval of traces containing information about item and contextual co-occurrences. Most recently, <span class="citation" data-cites="logan2021serial">@logan2021serial</span> introduced the Context Retrieval and Updating (CRU) model, which extends retrieved context theories’ conceptualization of context as a recency-weighted history of previously presented items to account for performance on whole report, serial recall, and copy typing tasks. Nonetheless, it remains unclear whether differences reported in related memory literatures between the performance of prototype- and instance-based memory models might similarly distinguish models of memory search.</p>
</section>
<section id="research-approach" class="level3">
<h3 class="anchored" data-anchor-id="research-approach">Research Approach</h3>
<p>In this paper, I show that the mechanisms proposed by the influential Context Maintanence and Retrieval (CMR) model of memory search <span class="citation" data-cites="morton2016predictive">[@morton2016predictive]</span> can be realized within either a prototypical or instance-based model architecture without substantially impacting performance across various experimental conditions. This instance-based CMR (InstanceCMR) extends the established MINERVA 2 multiple traces model <span class="citation" data-cites="hintzman1984minerva hintzman1986schema hintzman1988judgments">[@hintzman1984minerva; @hintzman1986schema; @hintzman1988judgments]</span> to support context-based memory search and simulate performance on the free recall task. I fit InstanceCMR and its original prototype-based counterpart (prototypeCMR) to the sequences of individual responses made by participants in three distinct free recall task datasets.I find that the models account for retrieval performance with similar effectiveness despite architectural differences, including over data manipulating the lengths of study lists between trials and other data manipulating the number of times particular items are studied within trials.</p>
<p>Analyses of the two specifications for CMR suggest that these outcomes can be largely explained by the model’s assumption that feature representations corresponding to studied items in free recall experiments are orthogonal — activation of each unit on an item feature layer corresponds to one item. This ensures that context-to-feature associations built via experience of one item do not overlap with associations built through experience of some other distinct item. Correspondingly, the influence of relevant experiences on the content of abstractive representations retrieved via these associations can be selectively enhanced while simultaneously suppressing the influence of less relevant experiences, without any interference. This capacity to nonlinearly modulate the influence of selected learning episodes on recall based on the content of a probe approximates trace-based activation functions realized within instance-based models, sidestepping issues reported about prototype-based memory models in other literatures.</p>


</section>
</section>
<script type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    setTimeout(function() {
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</main> <!-- /main -->
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->


</body></html>