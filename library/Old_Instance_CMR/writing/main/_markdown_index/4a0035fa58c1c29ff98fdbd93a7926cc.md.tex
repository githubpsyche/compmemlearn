--- jupyter: jupytext: text_representation: extension: .md format_name: pandoc format_version: 2.14.0.2 jupytext_version: 1.11.3 kernelspec: display_name: Python 3 (ipykernel) language: python name: python3 nbformat: 4\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{ nbformat_minor: 5}\markdownRendererInterblockSeparator
{}::: {.cell .markdown}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{Context Maintenance and Retrieval within an Instance-Based Architecture}\markdownRendererInterblockSeparator
{}:::\markdownRendererInterblockSeparator
{}::: {.cell .markdown} Our instance-based implementation of the context maintenance and retrieval model (InstanceCMR) realizes the retrieved context account of memory search [@morton2016predictive as articulated by] within the instance-based MINERVA 2 model architecture [@hintzman1984minerva]. To make comparison of architectures as straightforward as possible, mechanisms were deliberately specified to be as similar to those of the original prototypical specification as possible except where required by the constraints of the instance-based architecture. :::\markdownRendererInterblockSeparator
{}::: {.cell .markdown} ----------------------------------------------------------------------------------------------------------------------------------- Structure Type Symbol Name Description ----------------------- ------------------- ------------------------- ------------------------------------------------------------- Architecture \markdownRendererInterblockSeparator
{}\markdownRendererInputVerbatim{./_markdown_index/842b54f38085a72253be0f1245d37173.verbatim}\markdownRendererInterblockSeparator
{}Context Updating \markdownRendererInterblockSeparator
{}\markdownRendererInputVerbatim{./_markdown_index/2987263b0e41c84aec157c0dc8325840.verbatim}\markdownRendererInterblockSeparator
{}Associative Structure \markdownRendererInterblockSeparator
{}\markdownRendererInputVerbatim{./_markdown_index/4e3b707605e51c88271858798408a6d5.verbatim}\markdownRendererInterblockSeparator
{}Retrieval Dynamics \markdownRendererInterblockSeparator
{}\markdownRendererInputVerbatim{./_markdown_index/924b5c353689cafecfacf0cf99d3c658.verbatim}\markdownRendererInterblockSeparator
{}\markdownRendererHorizontalRule{}\markdownRendererInterblockSeparator
{}: Parameters and structures specifying InstanceCMR :::\markdownRendererInterblockSeparator
{}::: {.cell .markdown}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Model Architecture}\markdownRendererInterblockSeparator
{}:::\markdownRendererInterblockSeparator
{}::: {.cell .markdown} Prototypical CMR stores associations between item feature representations (represented a pattern of weights in an item layer $F$) and temporal context (represented in a contextual layer $C$) by integrating prototypical mappings between the representations via Hebbian learning over the course of encoding. In contrast, InstanceCMR tracks the history of interactions between context and item features by storing a discrete record of each experience, even repeated ones, as separate traces within in a memory store for later inspection. Memory for each experience is encoded as a separate row in an $m$ by $n$ memory matrix $M$ where rows correspond to memory traces and columns correspond to features. Each trace representing a pairing $i$ of a presented item's features $f_i$ and the temporal context of its presentation $c_i$ is encoded as a concatenated vector:\markdownRendererInterblockSeparator
{}\begin{equation} \label{eq:14}M_i = (f_i, c_i)\end{equation} :::\markdownRendererInterblockSeparator
{}::: {.cell .markdown}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Initial State}\markdownRendererInterblockSeparator
{}Structuring $M_i$ as a stack of concatenated item and contextual feature vectors $(f_i, c_i)$ makes it possible to define pre-experimental associations between items and contextual states similarly to the pattern by which PrototypeCMR\'s pre-experimental associations are specified in equations. To set pre-experimental associations, a trace is encoded into memory $M$ for each relevant item. Each entry $j$ for each item feature component of pre-experimental memory traces trace $f_{pre}(i)$ is set according to :::\relax