# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_Measuring_Repetition_Effects.ipynb (unless otherwise specified).

__all__ = ['recall_probability_by_lag', 'sim_recall_probability_by_lag']

# Cell
from numba import njit
import numpy as np

@njit(fastmath=True, nogil=True)
def recall_probability_by_lag(presentations, trials, experiment_count=1):

    presented, retrieved = np.zeros(5), np.zeros(5)

    for trial_index, sequence in enumerate(presentations):

        for experiment in range(experiment_count):

            # retrieve trial information
            trial = trials[trial_index*experiment_count + experiment]

            # extract list of recalled items
            recalled = sequence[trial-1][trial != 0]

            for item in np.unique(sequence):
                locations = np.where(sequence == item)[0]

                # presented just once
                if len(locations) == 1:
                    index = 0
                else:

                    # no intervening items (massed)
                    lag = locations[1] - locations[0] - 1
                    if lag == 0:
                        index = 1

                    # 1-2 intervening items
                    elif lag <= 2:
                        index = 2

                    # 3-5
                    elif lag <= 5:
                        index = 3

                    # 6-8
                    else:
                        index = 4

                presented[index] += 1
                retrieved[index] += item in recalled

    return retrieved, presented, retrieved/presented

# Cell

from tqdm import tqdm

def sim_recall_probability_by_lag(model_class, parameters, presentations, experiment_count=1000, savefig=False):
    """
    Apply organizational analyses to visually compare the behavior of the model
    with these parameters against specified dataset.
    """

    total_presented, total_retrieved = np.zeros(5), np.zeros(5)

    # generate simulation data from model
    for experiment in tqdm(range(experiment_count)):
        sim = np.zeros(np.shape(presentations), dtype=int)
        for trial_index, presentation in enumerate(presentations):

            item_count = np.max(presentation)+1
            model = model_class(**{'item_count': item_count, **parameters})

            # simulate study events
            try:
                model.experience(np.eye(model.item_count, model.item_count + 1, 1)[presentation])
            except ValueError:
                model.experience(np.eye(model.item_count, model.item_count)[presentation])

            # simulate and add recall events to trials array
            recalled = model.free_recall() + 1
            sim[trial_index, :len(recalled)] = recalled

        retrieved, presented = recall_probability_by_lag(presentations, sim)[:2]
        total_presented += presented
        total_retrieved += retrieved

    return total_retrieved, total_presented, total_retrieved/total_presented